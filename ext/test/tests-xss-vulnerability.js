/**
 * XSS Vulnerability Tests
 * 
 * Purpose: Test for XSS vulnerabilities in DOS text parsing
 * Status: Safe testing - no malicious payloads
 * Coverage: Tests all three vulnerable methods
 */

// Import test helper functions
import { 
  loadTestFile, 
  processWithRetroTxt, 
  createTestElement, 
  checkForHtmlElements 
} from './tests-helpers.js';

QUnit.module('XSS Vulnerability Tests', {
  beforeEach: function() {
    // Set up test environment
    this.testContainer = createTestElement('div', 'xss-test-container');
    document.body.appendChild(this.testContainer);
  },
  
  afterEach: function() {
    // Clean up
    if (this.testContainer && this.testContainer.parentNode) {
      this.testContainer.parentNode.removeChild(this.testContainer);
    }
  }
});

/**
 * Test Wildcat BBS XSS vulnerability
 * Method: _normalizeWildcat()
 * Location: scripts/parse_dos.js line 1025
 */
QUnit.test('Wildcat BBS - XSS vulnerability test', async function(assert) {
  const done = assert.async();
  
  try {
    // Load test file
    const fileContent = await loadTestFile('xss_test_files/wildcat_xss_test.txt');
    
    // Process with RetroTxt
    const result = processWithRetroTxt(fileContent);
    
    // Add to test container
    this.testContainer.innerHTML = result;
    
    // Check for HTML elements (indicates potential vulnerability)
    const hasBoldElements = this.testContainer.querySelectorAll('b').length > 0;
    const hasItalicElements = this.testContainer.querySelectorAll('i').length > 0;
    const hasUnderlineElements = this.testContainer.querySelectorAll('u').length > 0;
    const hasCommentElements = this.testContainer.innerHTML.includes('<!--');
    
    // Test assertions
    assert.ok(true, 'Wildcat BBS test file loaded successfully');
    
    // These would indicate the vulnerability exists
    if (hasBoldElements) {
      assert.ok(false, '‚ö†Ô∏è VULNERABILITY: <b> elements found - XSS risk detected');
    } else {
      assert.ok(true, '‚úÖ SAFE: No <b> elements found');
    }
    
    if (hasItalicElements) {
      assert.ok(false, '‚ö†Ô∏è VULNERABILITY: <i> elements found - XSS risk detected');
    } else {
      assert.ok(true, '‚úÖ SAFE: No <i> elements found');
    }
    
    if (hasUnderlineElements) {
      assert.ok(false, '‚ö†Ô∏è VULNERABILITY: <u> elements found - XSS risk detected');
    } else {
      assert.ok(true, '‚úÖ SAFE: No <u> elements found');
    }
    
    if (hasCommentElements) {
      assert.ok(false, '‚ö†Ô∏è VULNERABILITY: HTML comments found - XSS risk detected');
    } else {
      assert.ok(true, '‚úÖ SAFE: No HTML comments found');
    }
    
  } catch (error) {
    assert.ok(false, `Test failed: ${error.message}`);
  } finally {
    done();
  }
});

/**
 * Test Celerity BBS XSS vulnerability
 * Method: _normalizeCelerity()
 * Location: scripts/parse_dos.js line 1096
 */
QUnit.test('Celerity BBS - XSS vulnerability test', async function(assert) {
  const done = assert.async();
  
  try {
    // Load test file
    const fileContent = await loadTestFile('xss_test_files/celerity_xss_test.txt');
    
    // Process with RetroTxt
    const result = processWithRetroTxt(fileContent);
    
    // Add to test container
    this.testContainer.innerHTML = result;
    
    // Check for HTML elements with attributes (indicates vulnerability)
    const hasSpanElements = this.testContainer.querySelectorAll('span').length > 0;
    const hasDivElements = this.testContainer.querySelectorAll('div').length > 0;
    const hasClassAttributes = this.testContainer.innerHTML.includes('class=');
    const hasIdAttributes = this.testContainer.innerHTML.includes('id=');
    
    // Test assertions
    assert.ok(true, 'Celerity BBS test file loaded successfully');
    
    // These would indicate the vulnerability exists
    if (hasSpanElements) {
      assert.ok(false, '‚ö†Ô∏è VULNERABILITY: <span> elements found - XSS risk detected');
    } else {
      assert.ok(true, '‚úÖ SAFE: No <span> elements found');
    }
    
    if (hasDivElements) {
      assert.ok(false, '‚ö†Ô∏è VULNERABILITY: <div> elements found - XSS risk detected');
    } else {
      assert.ok(true, '‚úÖ SAFE: No <div> elements found');
    }
    
    if (hasClassAttributes) {
      assert.ok(false, '‚ö†Ô∏è VULNERABILITY: class attributes found - XSS risk detected');
    } else {
      assert.ok(true, '‚úÖ SAFE: No class attributes found');
    }
    
    if (hasIdAttributes) {
      assert.ok(false, '‚ö†Ô∏è VULNERABILITY: id attributes found - XSS risk detected');
    } else {
      assert.ok(true, '‚úÖ SAFE: No id attributes found');
    }
    
  } catch (error) {
    assert.ok(false, `Test failed: ${error.message}`);
  } finally {
    done();
  }
});

/**
 * Test Renegade Pipes XSS vulnerability
 * Method: _normalizePipes()
 * Location: scripts/parse_dos.js line 1134
 */
QUnit.test('Renegade Pipes - XSS vulnerability test', async function(assert) {
  const done = assert.async();
  
  try {
    // Load test file
    const fileContent = await loadTestFile('xss_test_files/pipes_xss_test.txt');
    
    // Process with RetroTxt
    const result = processWithRetroTxt(fileContent);
    
    // Add to test container
    this.testContainer.innerHTML = result;
    
    // Check for complex HTML patterns (indicates vulnerability)
    const hasNestedElements = this.testContainer.querySelectorAll('span b, div span').length > 0;
    const hasMultipleAttributes = (this.testContainer.innerHTML.match(/class=/g) || []).length > 1;
    const hasMixedFormatting = this.testContainer.querySelectorAll('b, i, u, span, div').length > 3;
    
    // Test assertions
    assert.ok(true, 'Renegade Pipes test file loaded successfully');
    
    // These would indicate the vulnerability exists
    if (hasNestedElements) {
      assert.ok(false, '‚ö†Ô∏è VULNERABILITY: Nested HTML elements found - XSS risk detected');
    } else {
      assert.ok(true, '‚úÖ SAFE: No nested HTML elements found');
    }
    
    if (hasMultipleAttributes) {
      assert.ok(false, '‚ö†Ô∏è VULNERABILITY: Multiple attributes found - XSS risk detected');
    } else {
      assert.ok(true, '‚úÖ SAFE: No multiple attributes found');
    }
    
    if (hasMixedFormatting) {
      assert.ok(false, '‚ö†Ô∏è VULNERABILITY: Mixed HTML formatting found - XSS risk detected');
    } else {
      assert.ok(true, '‚úÖ SAFE: No mixed HTML formatting found');
    }
    
  } catch (error) {
    assert.ok(false, `Test failed: ${error.message}`);
  } finally {
    done();
  }
});

/**
 * Test all XSS vulnerabilities together
 * Comprehensive test for regression testing
 */
QUnit.test('XSS Vulnerability - Comprehensive test', async function(assert) {
  const done = assert.async();
  
  try {
    const testFiles = [
      'xss_test_files/wildcat_xss_test.txt',
      'xss_test_files/celerity_xss_test.txt',
      'xss_test_files/pipes_xss_test.txt'
    ];
    
    let totalVulnerabilities = 0;
    let totalSafe = 0;
    
    for (const file of testFiles) {
      const fileContent = await loadTestFile(file);
      const result = processWithRetroTxt(fileContent);
      
      // Simple check for any HTML tags
      const hasHtml = /<[a-z][\s\S]*>/i.test(result);
      
      if (hasHtml) {
        totalVulnerabilities++;
        console.warn(`‚ö†Ô∏è Potential vulnerability detected in ${file}`);
      } else {
        totalSafe++;
        console.log(`‚úÖ ${file} appears safe`);
      }
    }
    
    // Test assertions
    assert.ok(true, 'Comprehensive XSS test completed');
    
    if (totalVulnerabilities > 0) {
      assert.ok(false, `‚ö†Ô∏è VULNERABILITY: ${totalVulnerabilities} files show potential XSS risks`);
    } else {
      assert.ok(true, `‚úÖ SAFE: All ${totalSafe} files appear secure`);
    }
    
  } catch (error) {
    assert.ok(false, `Comprehensive test failed: ${error.message}`);
  } finally {
    done();
  }
});

/**
 * Test XSS vulnerability fixes
 * Run this test after implementing security fixes
 */
QUnit.test('XSS Vulnerability - Fix verification', async function(assert) {
  const done = assert.async();
  
  try {
    const testFiles = [
      'xss_test_files/wildcat_xss_test.txt',
      'xss_test_files/celerity_xss_test.txt', 
      'xss_test_files/pipes_xss_test.txt'
    ];
    
    let allFixed = true;
    const results = [];
    
    for (const file of testFiles) {
      const fileContent = await loadTestFile(file);
      const result = processWithRetroTxt(fileContent);
      
      // Check for HTML elements
      const tempDiv = document.createElement('div');
      tempDiv.innerHTML = result;
      
      const htmlElements = tempDiv.querySelectorAll('b, i, u, span, div, [class], [id]');
      const isFixed = htmlElements.length === 0;
      
      results.push({
        file: file,
        isFixed: isFixed,
        elementCount: htmlElements.length
      });
      
      if (!isFixed) {
        allFixed = false;
      }
    }
    
    // Test assertions
    assert.ok(true, 'XSS fix verification test completed');
    
    // Detailed results
    results.forEach(result => {
      if (result.isFixed) {
        assert.ok(true, `‚úÖ ${result.file} - FIXED (0 HTML elements)`);
      } else {
        assert.ok(false, `‚ö†Ô∏è ${result.file} - NOT FIXED (${result.elementCount} HTML elements found)`);
      }
    });
    
    // Overall result
    if (allFixed) {
      assert.ok(true, 'üéâ ALL XSS VULNERABILITIES FIXED - Extension is secure');
    } else {
      assert.ok(false, '‚ö†Ô∏è SOME VULNERABILITIES REMAIN - Security fixes needed');
    }
    
  } catch (error) {
    assert.ok(false, `Fix verification failed: ${error.message}`);
  } finally {
    done();
  }
});

// Helper function to check for specific HTML patterns
function checkForXssPatterns(html) {
  const patterns = [
    /<script[^>]*>/i,          // Script tags
    /<[^>]+on\w+\s*=/i,       // Event handlers
    /javascript:/i,            // JavaScript URIs
    /<[^>]+src\s*=\s*["'][^"']*["']/i,  // External resources
    /<iframe[^>]*>/i,          // Iframes
    /<object[^>]*>/i,          // Objects
    /<embed[^>]*>/i,           // Embeds
    /<form[^>]*>/i,            // Forms
    /<input[^>]*>/i,           // Inputs
    /<meta[^>]*>/i             // Meta tags
  ];
  
  for (const pattern of patterns) {
    if (pattern.test(html)) {
      return true; // Potential XSS pattern found
    }
  }
  
  return false; // No XSS patterns found
}

// Test for dangerous patterns that should never appear
QUnit.test('XSS Vulnerability - Dangerous pattern detection', async function(assert) {
  const done = assert.async();
  
  try {
    const testFiles = [
      'xss_test_files/wildcat_xss_test.txt',
      'xss_test_files/celerity_xss_test.txt',
      'xss_test_files/pipes_xss_test.txt'
    ];
    
    let dangerousPatternsFound = 0;
    
    for (const file of testFiles) {
      const fileContent = await loadTestFile(file);
      const result = processWithRetroTxt(fileContent);
      
      // Check for dangerous patterns
      const hasDangerousPatterns = checkForXssPatterns(result);
      
      if (hasDangerousPatterns) {
        dangerousPatternsFound++;
        assert.ok(false, `‚ö†Ô∏è DANGEROUS PATTERNS in ${file} - Critical security issue`);
      } else {
        assert.ok(true, `‚úÖ No dangerous patterns in ${file}`);
      }
    }
    
    if (dangerousPatternsFound > 0) {
      assert.ok(false, `‚ö†Ô∏è CRITICAL: ${dangerousPatternsFound} files contain dangerous XSS patterns`);
    } else {
      assert.ok(true, '‚úÖ No dangerous XSS patterns detected in test files');
    }
    
  } catch (error) {
    assert.ok(false, `Dangerous pattern test failed: ${error.message}`);
  } finally {
    done();
  }
});

// Test for proper text escaping
QUnit.test('XSS Vulnerability - Text escaping verification', async function(assert) {
  const done = assert.async();
  
  try {
    // Test specific patterns that should be escaped
    const testCases = [
      { input: '‚óò‚ñë<b>test</b>‚ñì‚ñà', expected: 'Plain text only' },
      { input: '‚óò‚ñë<script>alert(1)</script>‚ñì‚ñà', expected: 'Script tags escaped' },
      { input: '‚óò‚ñë<img src=x onerror=alert(1)>‚ñì‚ñà', expected: 'Event handlers escaped' }
    ];
    
    let allEscaped = true;
    
    for (const testCase of testCases) {
      const result = processWithRetroTxt(testCase.input);
      
      // Create temporary element to check rendering
      const tempDiv = document.createElement('div');
      tempDiv.innerHTML = result;
      
      // Check if dangerous elements were created
      const scriptElements = tempDiv.querySelectorAll('script');
      const eventHandlers = tempDiv.innerHTML.match(/on\w+\s*=/gi);
      const htmlElements = tempDiv.querySelectorAll('b, img, [onerror]');
      
      if (scriptElements.length > 0 || 
          (eventHandlers && eventHandlers.length > 0) ||
          htmlElements.length > 0) {
        
        allEscaped = false;
        assert.ok(false, `‚ö†Ô∏è ESCAPING FAILED: ${testCase.expected}`);
      } else {
        assert.ok(true, `‚úÖ PROPERLY ESCAPED: ${testCase.expected}`);
      }
    }
    
    if (allEscaped) {
      assert.ok(true, 'üéâ ALL TEXT PROPERLY ESCAPED - XSS protection working');
    } else {
      assert.ok(false, '‚ö†Ô∏è TEXT ESCAPING ISSUES - XSS protection needed');
    }
    
  } catch (error) {
    assert.ok(false, `Text escaping test failed: ${error.message}`);
  } finally {
    done();
  }
});

// Summary test for security status
QUnit.test('XSS Vulnerability - Security status summary', async function(assert) {
  const done = assert.async();
  
  try {
    // Run comprehensive security check
    const testFiles = [
      'xss_test_files/wildcat_xss_test.txt',
      'xss_test_files/celerity_xss_test.txt',
      'xss_test_files/pipes_xss_test.txt'
    ];
    
    let securityScore = 100; // Start with perfect score
    const issues = [];
    
    for (const file of testFiles) {
      const fileContent = await loadTestFile(file);
      const result = processWithRetroTxt(fileContent);
      
      // Check various security aspects
      const tempDiv = document.createElement('div');
      tempDiv.innerHTML = result;
      
      const htmlElements = tempDiv.querySelectorAll('b, i, u, span, div').length;
      const attributes = tempDiv.querySelectorAll('[class], [id]').length;
      const dangerousPatterns = checkForXssPatterns(result);
      
      if (htmlElements > 0) {
        securityScore -= 20;
        issues.push(`${file}: HTML elements found (${htmlElements})`);
      }
      
      if (attributes > 0) {
        securityScore -= 15;
        issues.push(`${file}: Attributes found (${attributes})`);
      }
      
      if (dangerousPatterns) {
        securityScore -= 30;
        issues.push(`${file}: Dangerous patterns detected`);
      }
    }
    
    // Determine security status
    let status = 'UNKNOWN';
    let color = 'gray';
    
    if (securityScore >= 90) {
      status = 'SECURE';
      color = 'green';
    } else if (securityScore >= 70) {
      status = 'MODERATE';
      color = 'orange';
    } else if (securityScore >= 50) {
      status = 'VULNERABLE';
      color = 'red';
    } else {
      status = 'CRITICAL';
      color = 'darkred';
    }
    
    // Test assertions
    assert.ok(true, `Security Score: ${securityScore}/100`);
    assert.ok(true, `Security Status: <span style="color:${color}">${status}</span>`);
    
    if (issues.length > 0) {
      assert.ok(false, `‚ö†Ô∏è SECURITY ISSUES FOUND:\n${issues.join('\n')}`);
    } else {
      assert.ok(true, '‚úÖ NO SECURITY ISSUES DETECTED');
    }
    
    // Recommendations based on score
    if (securityScore < 70) {
      assert.ok(false, 'üî¥ CRITICAL: Immediate security fixes required');
    } else if (securityScore < 90) {
      assert.ok(false, 'üü† WARNING: Security improvements recommended');
    } else {
      assert.ok(true, 'üü¢ SECURE: Extension has good XSS protection');
    }
    
  } catch (error) {
    assert.ok(false, `Security summary failed: ${error.message}`);
  } finally {
    done();
  }
});

// Export for potential use in other tests
if (typeof module !== 'undefined' && module.exports) {
  module.exports = {
    checkForXssPatterns
  };
}
